"""
Malware Detection Prediction Script
Extracts API calls from JSON trace and uses trained CNN model to predict malware
"""

import json
import numpy as np
import pickle
from pathlib import Path
import keras


class MalwarePredictor:
    def __init__(self, model_path, vocab_path, max_sequence_length=2000):
        """
        Initialize predictor with trained model and vocabulary.
        
        Args:
            model_path: Path to trained .keras model file
            vocab_path: Path to vocabulary pickle file
            max_sequence_length: Maximum sequence length (default 2000)
        """
        print("Loading model and vocabulary...")
        
        # Load model
        self.model = keras.models.load_model(model_path)
        print(f"✓ Model loaded from {model_path}")
        
        # Load vocabulary
        with open(vocab_path, 'rb') as f:
            self.vocab = pickle.load(f)
        print(f"✓ Vocabulary loaded from {vocab_path}")
        print(f"  Vocabulary size: {len(self.vocab)}")
        
        # Store max sequence length
        self.max_sequence_length = max_sequence_length
    
    def extract_api_sequence(self, json_file_path):
        """
        Extract API call sequence from JSON trace file.
        
        Args:
            json_file_path: Path to JSON file with api_sequence
            
        Returns:
            List of API call names in sequence
        """
        print(f"\nExtracting API calls from {json_file_path}...")
        
        with open(json_file_path, 'r') as f:
            data = json.load(f)
        
        # Extract API call names from api_sequence
        api_calls = []
        if 'api_sequence' in data:
            for call in data['api_sequence']:
                if 'api' in call:
                    api_calls.append(call['api'])
        
        print(f"✓ Extracted {len(api_calls)} API calls")
        
        if len(api_calls) > 0:
            # Show first few calls
            print(f"  First 10 calls: {api_calls[:10]}")
            
            # Count unique APIs
            unique_apis = len(set(api_calls))
            print(f"  Unique APIs: {unique_apis}")
        
        return api_calls
    
    def sequence_to_indices(self, api_sequence):
        """Convert API sequence to indices."""
        indices = []
        for api in api_sequence:
            api_lower = api.lower()
            indices.append(self.vocab.get(api_lower, 1))  # 1 = <UNK>
        return indices
    
    def pad_sequence(self, sequence):
        """Pad sequence to max_sequence_length."""
        padded = np.zeros((1, self.max_sequence_length), dtype=np.int32)
        
        if len(sequence) > self.max_sequence_length:
            # Truncate from the beginning (keep most recent calls)
            padded[0] = sequence[-self.max_sequence_length:]
        else:
            # Pad at the beginning
            padded[0, -len(sequence):] = sequence
        
        return padded
    
    def predict(self, json_file_path):
        """
        Predict malware classification for API trace.
        
        Args:
            json_file_path: Path to JSON file with API trace
            
        Returns:
            Dict with prediction results and confidence
        """
        # Extract API calls
        api_calls = self.extract_api_sequence(json_file_path)
        
        if len(api_calls) == 0:
            return {
                'error': 'No API calls found in JSON file',
                'prediction': None,
                'confidence': 0.0
            }
        
        # Convert to indices
        print("\nPreprocessing sequence...")
        indexed_sequence = self.sequence_to_indices(api_calls)
        
        # Count unknown APIs
        unknown_count = sum(1 for idx in indexed_sequence if idx == 1)
        known_count = len(indexed_sequence) - unknown_count
        print(f"  Known APIs in vocabulary: {known_count}/{len(indexed_sequence)} ({known_count/len(indexed_sequence)*100:.1f}%)")
        print(f"  Unknown APIs (not in training): {unknown_count}/{len(indexed_sequence)} ({unknown_count/len(indexed_sequence)*100:.1f}%)")
        
        # Pad sequence
        padded_sequence = self.pad_sequence(indexed_sequence)
        print(f"  Padded to {self.max_sequence_length} length")
        
        # Make prediction
        print("\nMaking prediction...")
        prediction_proba = self.model.predict(padded_sequence, verbose=0)[0][0]
        
        # Binary classification: 0 = benign, 1 = malicious
        is_malicious = prediction_proba > 0.5
        confidence = prediction_proba if is_malicious else (1 - prediction_proba)
        
        result = {
            'prediction': 'MALICIOUS' if is_malicious else 'BENIGN',
            'confidence': float(confidence),
            'malicious_probability': float(prediction_proba),
            'benign_probability': float(1 - prediction_proba),
            'total_api_calls': len(api_calls),
            'unique_api_calls': len(set(api_calls)),
            'known_apis': known_count,
            'unknown_apis': unknown_count,
            'sequence_truncated': len(api_calls) > self.max_sequence_length
        }
        
        return result
    
    def print_prediction_report(self, result):
        """Print formatted prediction report."""
        print("\n" + "="*70)
        print("MALWARE DETECTION REPORT")
        print("="*70)
        
        if 'error' in result:
            print(f"\n❌ Error: {result['error']}")
            return
        
        # Prediction
        prediction = result['prediction']
        confidence = result['confidence']
        
        if prediction == 'MALICIOUS':
            symbol = "⚠️"
            color_code = "\033[91m"  # Red
        else:
            symbol = "✓"
            color_code = "\033[92m"  # Green
        
        reset_code = "\033[0m"
        
        print(f"\n{symbol} Prediction: {color_code}{prediction}{reset_code}")
        print(f"   Confidence: {confidence*100:.2f}%")
        
        # Probabilities
        print(f"\nProbability Breakdown:")
        print(f"  Malicious: {result['malicious_probability']*100:.2f}%")
        print(f"  Benign:    {result['benign_probability']*100:.2f}%")
        
        # Confidence bar
        print(f"\nConfidence Bar:")
        bar_length = 50
        filled = int(result['malicious_probability'] * bar_length)
        bar = "[" + "█" * filled + "░" * (bar_length - filled) + "]"
        print(f"  Benign {bar} Malicious")
        print(f"  0%     {' '*20}50%{' '*20}100%")
        
        # API call statistics
        print(f"\nAPI Call Statistics:")
        print(f"  Total API calls: {result['total_api_calls']}")
        print(f"  Unique API calls: {result['unique_api_calls']}")
        print(f"  Known in vocabulary: {result['known_apis']} ({result['known_apis']/result['total_api_calls']*100:.1f}%)")
        print(f"  Unknown (unseen): {result['unknown_apis']} ({result['unknown_apis']/result['total_api_calls']*100:.1f}%)")
        
        if result['sequence_truncated']:
            print(f"  ⚠️  Sequence was truncated to {self.max_sequence_length} calls")
        
        print("\n" + "="*70)


def main():
    """Main prediction function."""
    
    # Configuration
    MODEL_PATH = "C:/Users/willi/OneDrive/Test/K/backend/training_script/best_fixed_cnn_model.keras"
    VOCAB_PATH = r"C:\Users\willi\OneDrive\Test\K\backend\training_script\api_vocab_fixed.pkl"
    JSON_TRACE_PATH = "C:/Users/willi/OneDrive/Test/K/testing_code/activity_monitor/api_trace_ntdll.json"
    JSON_MAL_TRACE_PATH = "C:/Users/willi/OneDrive/Test/K/testing_code/activity_monitor/api_trace_malicious_synthetic.json"
    
    print("="*70)
    print("MALWARE DETECTION USING CNN")
    print("="*70)
    
    # Check if files exist
    from pathlib import Path
    
    if not Path(MODEL_PATH).exists():
        print(f"\n❌ Error: Model file not found at {MODEL_PATH}")
        print("   Please train the model first using train_cnn_combined_datasets.py")
        return
    
    if not Path(VOCAB_PATH).exists():
        print(f"\n❌ Error: Vocabulary file not found at {VOCAB_PATH}")
        print("   Please train the model first using train_cnn_api_calls.py or train_cnn_combined_datasets.py")
        return
    
    if not Path(JSON_MAL_TRACE_PATH).exists():
        print(f"\n❌ Error: JSON trace file not found at {JSON_MAL_TRACE_PATH}")
        return
    
    # Initialize predictor
    predictor = MalwarePredictor(MODEL_PATH, VOCAB_PATH)
    
    # Make prediction
    result = predictor.predict(JSON_MAL_TRACE_PATH)
    
    # Print report
    predictor.print_prediction_report(result)
    
    # Return result for programmatic use
    return result


if __name__ == "__main__":
    result = main()
